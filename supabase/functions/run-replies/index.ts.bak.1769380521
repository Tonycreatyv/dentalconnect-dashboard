/// <reference types="https://deno.land/x/types/index.d.ts" />

import { createClient } from "jsr:@supabase/supabase-js@2";

type ClaimRow = {
  id: string;
  organization_id: string;
  lead_id: string;
  channel: string;
  channel_user_id: string;
  inbound_message_id: string;
  attempt_count: number;
};

function json(resBody: unknown, status = 200) {
  return new Response(JSON.stringify(resBody), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
    },
  });
}

async function openaiReply(message: string) {
  const apiKey = Deno.env.get("OPENAI_API_KEY");
  if (!apiKey) throw new Error("Missing OPENAI_API_KEY");

  const body = {
    model: "gpt-4o-mini",
    temperature: 0.2,
    messages: [
      {
        role: "system",
        content: "Eres un asistente comercial B2C. Responde en espaÃ±ol, breve, claro y orientado al siguiente paso. Sin emojis.",

      },
      { role: "user", content: message },
    ],
  };

  const r = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });

  if (!r.ok) {
    const t = await r.text();
    throw new Error(`OpenAI error ${r.status}: ${t}`);
  }

  const data = await r.json();
  const reply = data?.choices?.[0]?.message?.content?.trim();
  if (!reply) throw new Error("OpenAI returned empty reply");
  return reply;
}

async function sendToMeta(recipientId: string, text: string) {
  const token = Deno.env.get("META_PAGE_ACCESS_TOKEN");
  const version = Deno.env.get("META_GRAPH_VERSION") || "v21.0";
  if (!token) throw new Error("Missing META_PAGE_ACCESS_TOKEN");

  const url = `https://graph.facebook.com/${version}/me/messages`;
  const payload = {
    messaging_type: "RESPONSE",
    recipient: { id: recipientId },
    message: { text },
  };

  const r = await fetch(url, {
    method: "POST",
    headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  if (!r.ok) {
    const t = await r.text();
    throw new Error(`Meta send error ${r.status}: ${t}`);
  }
}

Deno.serve(async (req) => {
  // preflight
  if (req.method === "OPTIONS") return json({ ok: true }, 200);

  // Auth: secret propio
  const secret = Deno.env.get("REPLY_RUN_SECRET");
  const got = req.headers.get("x-reply-secret");
  if (!secret) return json({ error: "Missing REPLY_RUN_SECRET" }, 500);
  if (got !== secret) return json({ error: "Unauthorized" }, 401);

  const { org, limit } = await req.json().catch(() => ({ org: null, limit: 10 }));
  if (!org) return json({ error: "Missing org" }, 400);

  const supabaseUrl = Deno.env.get("SUPABASE_URL");
  const serviceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
  if (!supabaseUrl || !serviceKey) {
    return json({ error: "Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY" }, 500);
  }

  const sb = createClient(supabaseUrl, serviceKey);

  // 1) Claim
  const { data: claimed, error: claimErr } = await sb.rpc("claim_reply_outbox", {
    p_org: org,
    p_limit: limit ?? 10,
  });

  if (claimErr) return json({ error: "claim_failed", detail: claimErr }, 500);

  const items: ClaimRow[] = claimed ?? [];
  if (items.length === 0) return json({ ok: true, claimed: 0 });

  const results: any[] = [];

  for (const o of items) {
    try {
      // 2) Fetch inbound message text
      const { data: inbound, error: inboundErr } = await sb
        .from("messages")
        .select("content")
        .eq("id", o.inbound_message_id)
        .single();

      if (inboundErr) throw new Error(`inbound_fetch_failed: ${inboundErr.message}`);
      const inboundText = (inbound?.content ?? "").toString();

      // 3) OpenAI reply
      const reply = await openaiReply(inboundText);

      // 4) Send to Meta only if messenger/instagram
      if (o.channel === "messenger" || o.channel === "instagram") {
        await sendToMeta(o.channel_user_id, reply);
      }

      // 5) Mark sent (DB writes)
      const { error: sentErr } = await sb.rpc("mark_reply_sent", {
        p_outbox_id: o.id,
        p_reply: reply,
      });
      if (sentErr) throw new Error(`mark_sent_failed: ${sentErr.message}`);

      results.push({ outbox_id: o.id, status: "sent" });
    } catch (e) {
      const msg = (e as Error)?.message ?? "unknown_error";
      await sb.rpc("mark_reply_failed", {
        p_outbox_id: o.id,
        p_error: msg,
      });
      results.push({ outbox_id: o.id, status: "failed", error: msg });
    }
  }

  return json({ ok: true, claimed: items.length, results });
});

